<!-- 
  CosmicAR - 2D Bracelet VTO (Google Edge / World Landmarks Logic)
  FIX: Uses WorldLandmarks (3D metric data) for perfect tracking & rotation.
  FIX: Vector Math for accurate Palm Up/Down detection.
-->
<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CosmicAR - Perfect Follow</title>
    <!-- MediaPipe Hands (Classic API used with WorldLandmarks feature) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            background: #000; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #app-container {
            width: 100%; height: 100%; max-width: 480px; margin: 0 auto;
            position: relative; background: #000; overflow: hidden;
        }

        @media (min-width: 481px) {
            body { background: #1a1a1a; display: flex; align-items: center; justify-content: center; }
            #app-container { height: 90vh; aspect-ratio: 9/16; border-radius: 24px; box-shadow: 0 20px 60px rgba(0,0,0,0.6); }
        }

        /* VIDEO LAYER */
        #video-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; object-fit: cover; }
        #input_video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        /* AR LAYER (3D Context) */
        #ar-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none; perspective: 1000px;
        }

        /* WRIST ANCHOR */
        #wrist-anchor {
            position: absolute; top: 50%; left: 50%;
            width: 0; height: 0; transform-style: preserve-3d; will-change: transform;
        }

        /* JEWELRY WRAPPER */
        #jewelry-wrapper {
            position: absolute; left: 0; top: 0; transform-style: preserve-3d;
        }

        #jewelry-img {
            display: block; transform: translate(-50%, -50%);
            filter: drop-shadow(0 10px 20px rgba(0,0,0,0.35));
            max-width: none; pointer-events: none;
        }

        /* DASHED ARC */
        #dashed-arc {
            position: absolute; left: 0; top: 0;
            transform: translate(-50%, -50%) translateZ(-40px) rotateX(-75deg);
            border-radius: 50%; border: 10px dashed rgba(255, 255, 255, 0.8);
            pointer-events: none; opacity: 0;
        }
        @keyframes dash-spin {
            from { border-color: rgba(255,255,255,0.4); } 50% { border-color: rgba(255,255,255,0.9); } to { border-color: rgba(255,255,255,0.4); }
        }
        #dashed-arc.active { animation: dash-spin 2s infinite ease-in-out; }

        /* UI LAYER */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; pointer-events: none; }
        #instruction-text {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); color: white; padding: 10px 18px; border-radius: 20px;
            font-size: 13px; text-align: center; backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1); white-space: nowrap;
        }
        .btn {
            pointer-events: auto; background: rgba(30,30,30,0.8); backdrop-filter: blur(12px);
            color: white; border: 1px solid rgba(255,255,255,0.15); border-radius: 16px;
            font-weight: 600; cursor: pointer; transition: all 0.2s; font-size: 12px;
        }
        .btn:active { transform: scale(0.95); background: rgba(50,50,50,0.9); }
        .top-controls { position: absolute; top: 10px; left: 0; width: 100%; display: flex; justify-content: space-between; padding: 0 12px; }
        .bottom-controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 92%; display: flex; flex-direction: column; gap: 12px; pointer-events: auto; }
        .mode-selector { display: flex; gap: 6px; background: rgba(30,30,30,0.85); padding: 4px; border-radius: 20px; backdrop-filter: blur(12px); }
        .mode-btn { flex: 1; background: transparent; color: rgba(255,255,255,0.6); border: none; padding: 10px; border-radius: 16px; font-size: 13px; cursor: pointer; transition: all 0.2s; font-weight: 600; }
        .mode-btn.active { background: #fff; color: #000; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
        .loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; z-index: 1000; background: rgba(0,0,0,0.95); padding: 20px 30px; border-radius: 16px; font-size: 14px; text-align: center; border: 1px solid rgba(255,255,255,0.1); }
    </style>
</head>
<body>
    <div id="app-container">
        <div class="loading" id="loading">Kamera inicializ√°l√°sa...</div>
        <div id="video-layer"><video id="input_video" playsinline></video></div>
        <div id="ar-layer">
            <div id="wrist-anchor">
                <div id="jewelry-wrapper"><img id="jewelry-img" src="" alt="jewelry" style="display:none;"></div>
                <div id="dashed-arc"></div>
            </div>
        </div>
        <div id="ui-layer">
            <div class="top-controls">
                <button class="btn icon-btn" onclick="toggleMirror()">üîÑ T√ºk√∂r</button>
                <button class="btn icon-btn" onclick="toggleCamera()">üì∑ Kamera</button>
            </div>
            <div id="instruction-text">Tartsd a csukl√≥dat a kamera fel√©</div>
            <div class="bottom-controls">
                <div class="mode-selector">
                    <button class="mode-btn active" id="btn-bracelet" onclick="setMode('bracelet')">üìø Kark√∂t≈ë</button>
                    <button class="mode-btn" id="btn-ring" onclick="setMode('ring')">üíç Gy≈±r≈±</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 1. KONFIGUR√ÅCI√ì ---
        const CONFIG = {
            assetsPath: './assets/',
            smoothingPos: 0.2,
            smoothingRot: 0.2,
            smoothingVis: 0.1,
            baseScaleBracelet: 1.0, // World landmark miatt ez m√°s sk√°l√°z√°st ig√©nyel
            baseScaleRing: 1.0,
            worldScaleFactor: 60  // Faktor, amivel a m√©teres adatot pixell√© konvert√°ljuk
        };

        // --- 2. √ÅLLAPOT ---
        let currentMode = 'bracelet';
        let currentCamera = 'environment';
        let isMirrored = true;
        let isVideoReady = false;
        
        let state = {
            x: 0.5, y: 0.5,
            rotationZ: 0, rotationY: 0, rotationX: 0,
            scale: 1, scaleX: 1,
            arcOpacity: 0, visibility: 1,
            isPalmFacingUp: false
        };
        
        let target = { ...state };

        // --- 3. DOM REFERENCI√ÅK ---
        const videoElement = document.getElementById('input_video');
        const wristAnchor = document.getElementById('wrist-anchor');
        const jewelryWrapper = document.getElementById('jewelry-wrapper');
        const jewelryImg = document.getElementById('jewelry-img');
        const dashedArc = document.getElementById('dashed-arc');
        const appContainer = document.getElementById('app-container');

        // --- 4. MATEMATIKAI SEG√âDF√úGGV√âNYEK (VEKTOROK) ---
        // Google Edge st√≠lus√∫ matematika
        
        // 3D Vektor oszt√°ly
        class Vector3 {
            constructor(x, y, z) { this.x = x; this.y = y; this.z = z; }
            subtract(v) { return new Vector3(this.x - v.x, this.y - v.y, this.z - v.z); }
            normalize() { const m = Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z); return m === 0 ? new Vector3(0,0,0) : new Vector3(this.x/m, this.y/m, this.z/m); }
            cross(v) { return new Vector3(this.y*v.z - this.z*v.y, this.z*v.x - this.x*v.z, this.x*v.y - this.y*v.x); }
            dot(v) { return this.x*v.x + this.y*v.y + this.z*v.z; }
        }

        function loadAsset(type) {
            const img = new Image();
            const src = type === 'bracelet' ? CONFIG.assetsPath + 'bracelet.png' : CONFIG.assetsPath + 'ring.png';
            img.onload = () => {
                jewelryImg.src = src; jewelryImg.style.display = 'block';
                const aspect = img.naturalHeight / img.naturalWidth;
                const baseW = type === 'bracelet' ? 200 : 80;
                jewelryImg.style.width = baseW + 'px'; jewelryImg.style.height = (baseW * aspect) + 'px';
            };
            img.onerror = () => { document.getElementById('instruction-text').textContent = "Hiba: 'assets' mappa?"; };
            img.src = src;
        }

        // --- 5. MEDIAPIPE BE√ÅLL√çT√ÅS (WORLD LANDMARKS) ---
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6,
            // Fontos: enged√©lyezz√ºk a world landmarks-et
            // A classic API automatikusan visszaadja, ha a CameraUtils-t haszn√°ljuk
        });

        hands.onResults(onResults);

        // --- 6. LOGIKA (A MEGOLD√ÅS) ---
        function onResults(results) {
            if (!isVideoReady) return;
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                target.visibility = 0; target.arcOpacity = 0; return;
            }

            // K√âTF√âLE ADATUNK VAN:
            // 1. landmarks: K√©perny≈ë koordin√°t√°k (2D) - Poz√≠ci√≥hoz
            // 2. multiHandWorldLandmarks: Metrikus 3D koordin√°t√°k (m√©terben) - Forg√°shoz √©s Sk√°l√°hoz
            
            const landmarks = results.multiHandLandmarks[0]; // Screen coords
            const worldLandmarks = results.multiHandWorldLandmarks[0]; // World coords (Meters)

            const screenW = appContainer.offsetWidth;
            const screenH = appContainer.offsetHeight;

            if (currentMode === 'bracelet') {
                // --- 1. POZ√çCI√ì (Screen Coords - egyszer≈± √©s gyors) ---
                // Csukl√≥ √©s K√∂z√©ps≈ë ujj alapja k√∂z√©ppontja
                const wrist = landmarks[0];
                const midBase = landmarks[9];
                
                // K√∂z√©pre igaz√≠t√°s (lejjebb h√∫zva)
                let centerX = (wrist.x + midBase.x) / 2;
                let centerY = (wrist.y + midBase.y) / 2;
                
                // Ha t√ºk√∂r van, invert√°ljuk az X-et
                if (isMirrored) centerX = 1 - centerX;

                target.x = centerX;
                target.y = centerY;

                // --- 2. FORGAT√ÅS √âS SK√ÅLA (World Coords - Pontos) ---
                // Vektorok kinyer√©se a 3D koordin√°t√°kb√≥l
                const w = new Vector3(worldLandmarks[0].x, worldLandmarks[0].y, worldLandmarks[0].z); // Wrist
                const i = new Vector3(worldLandmarks[5].x, worldLandmarks[5].y, worldLandmarks[5].z); // Index MCP
                const p = new Vector3(worldLandmarks[17].x, worldLandmarks[17].y, worldLandmarks[17].z); // Pinky MCP

                // A k√©z teny√©r s√≠kj√°nak vektora (Norm√°lvektor sz√°m√≠t√°s)
                // Vektor a h√ºvelykujjt√≥l a kisujjig
                const vecIP = i.subtract(p);
                // Vektor a csukl√≥t√≥l a k√©zfej k√∂zep√©ig (kb)
                const vecWMid = i.subtract(w); 
                
                // Keresztszorzat (Cross Product) megadja a teny√©r "lefel√©" ir√°ny√°t
                // Figyelem: MediaPipe koordin√°tarendszere: Y fel, Z kamera fel√©?
                // A gyakorlatban finomhangolni kell az ir√°nyokat.
                const palmNormal = vecIP.cross(vecWMid).normalize();

                // --- T√ñK√âLETES TENY√âR IR√ÅNY (Palm Up/Down) ---
                // Ha a teny√©r norm√°lvektor√°nak Z komponense negat√≠v, akkor a teny√©r a kamera fel√© n√©z
                // (Ez a MediaPipe WorldLandmarks specifikum alapj√°n)
                
                // Kamera ir√°nyvektora (felt√©telezve, hogy a kamera 0,0,-1 fel√© n√©z, vagy 0,0,1)
                // MediaPipe-ban a Z n√∂vekszik a kamer√°t√≥l t√°volodva.
                // Ha a teny√©r norm√°l Z < 0, akkor a teny√©r a kamera fel√© n√©z.
                
                target.isPalmFacingUp = palmNormal.z < 0;

                // --- SK√ÅL√ÅZ√ÅS (Val√≥s m√©ret) ---
                // A h√ºvelykujj √©s kisujj t√°vols√°ga m√©terben
                const widthMeters = i.subtract(p).length();
                // √Åtv√°lt√°s pixelre (k√≠s√©rleti √©rt√©k, a kamera f√≥kuszt√≥l f√ºgg, de ar√°nyos)
                // Mivel a distance m√©terben van, el√©g egy fix szorz√≥t alkalmazni
                target.scale = widthMeters * CONFIG.worldScaleFactor * CONFIG.baseScaleBracelet;

                // --- FORGAT√ÅS (Roll/Pitch/Yaw) ---
                // Roll: A k√©z d≈ël√©se a Z tengely k√∂r√ºl (b√°rmi jobbra-balra)
                // A 'vecIP' vektor X √©s Y komponens√©b≈ël sz√°molhat√≥
                let rollRad = Math.atan2(vecIP.x, vecIP.y);
                let rollDeg = rollRad * (180 / Math.PI);
                
                // Korrekci√≥: A kark√∂t≈ë alapb√≥l 0 fokon fekszik, de a k√©zfej ir√°ny√°t kell k√∂vetnie
                rollDeg += 90; // Korrekci√≥, hogy a kark√∂t≈ë ne legyen mer≈ëleges a karra

                target.rotationZ = rollDeg;

                // Yaw (Oldalra fordul√°s) - Becsl√©s a norm√°lvektor X alapj√°n
                target.rotationY = palmNormal.x * 90; // Forgat√°s oldalra

                // Pitch (Felfel√©/lefel√© hajl√°s) - Becsl√©s a norm√°lvektor Y alapj√°n
                target.rotationX = palmNormal.y * 45;

                // Fake Bending (ScaleX)
                // Ha oldalra fordulunk (PalmNormal.x nagy), a k√©z "v√©konyabbnak" t≈±nik
                const absYaw = Math.abs(palmNormal.x);
                target.scaleX = 1.0 - (absYaw * 0.5); // Oldalra fordul√°skor v√©konyodik

            } else {
                // GY≈∞R≈∞ M√ìD (Hasonl√≥ logika, de ujjra)
                const w = new Vector3(worldLandmarks[0].x, worldLandmarks[0].y, worldLandmarks[0].z);
                const tip = new Vector3(worldLandmarks[12].x, worldLandmarks[12].y, worldLandmarks[12].z); // Gy≈±r≈±sujj
                const mcp = new Vector3(worldLandmarks[13].x, worldLandmarks[13].y, worldLandmarks[13].z);

                // Poz√≠ci√≥ (Screen)
                target.x = isMirrored ? 1 - landmarks[13].x : landmarks[13].x;
                target.y = landmarks[13].y;

                // Forgat√°s
                const vecFinger = tip.subtract(mcp);
                let angle = Math.atan2(vecFinger.x, vecFinger.y) * (180 / Math.PI) + 90;
                target.rotationZ = angle;
                target.rotationY = 0;
                target.scaleX = 1;

                // Sk√°la
                const lenMeters = vecFinger.length();
                target.scale = lenMeters * CONFIG.worldScaleFactor * 4; // Gy≈±r≈±h√∂z m√°s szorz√≥
            }
        }

        // --- 7. RENDER LOOP ---
        function animate() {
            const screenW = appContainer.offsetWidth;
            const screenH = appContainer.offsetHeight;

            // Lerp (Sim√≠t√°s)
            state.x = lerp(state.x, target.x, CONFIG.smoothingPos);
            state.y = lerp(state.y, target.y, CONFIG.smoothingPos);
            state.rotationZ = lerp(state.rotationZ, target.rotationZ, CONFIG.smoothingRot);
            state.rotationY = lerp(state.rotationY, target.rotationY, CONFIG.smoothingRot);
            state.rotationX = lerp(state.rotationX, target.rotationX, CONFIG.smoothingRot);
            state.scaleX = lerp(state.scaleX, target.scaleX, 0.1);
            state.scale = lerp(state.scale, target.scale, CONFIG.smoothingPos);
            state.arcOpacity = lerp(state.arcOpacity, target.arcOpacity, CONFIG.smoothingVis);
            state.visibility = lerp(state.visibility, target.visibility, CONFIG.smoothingVis);

            // √ÅTT≈∞N√âS (Vektor alap√∫ - Pontos)
            if (currentMode === 'bracelet') {
                if (state.isPalmFacingUp) {
                    // Teny√©r felfel√© -> Arc l√°tszik
                    target.visibility = 0;
                    target.arcOpacity = 1;
                } else {
                    // Teny√©r lefel√© -> Kark√∂t≈ë l√°tszik
                    target.visibility = 1;
                    target.arcOpacity = 0;
                }
            } else {
                target.visibility = 1; target.arcOpacity = 0;
            }

            // Update DOM
            const pixelX = state.x * screenW;
            const pixelY = state.y * screenH;

            wristAnchor.style.left = pixelX + 'px';
            wristAnchor.style.top = pixelY + 'px';
            
            // A forgat√°st most m√°r egybe√©p√≠tj√ºk
            // Mivel a CSS rot√°ci√≥ sorrendje fontos: Z -> Y -> X
            wristAnchor.style.transform = `rotateZ(${state.rotationZ}deg) rotateY(${state.rotationY}deg) rotateX(${state.rotationX}deg)`;

            jewelryWrapper.style.opacity = state.visibility;
            jewelryWrapper.style.transform = `scale(${state.scale * state.scaleX}, ${state.scale})`;

            dashedArc.style.opacity = state.arcOpacity;
            dashedArc.style.transform = `translate(-50%, -50%) translateZ(-40px) rotateX(-75deg)`;

            if (state.arcOpacity > 0.1) dashedArc.classList.add('active');
            else dashedArc.classList.remove('active');

            requestAnimationFrame(animate);
        }

        function lerp(start, end, factor) { return start + (end - start) * factor; }

        // --- INIT ---
        function initCamera() {
            document.getElementById('loading').style.display = 'block';
            if (window.camera) try { window.camera.stop(); } catch(e){}
            window.camera = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 1280, height: 720, facingMode: currentCamera
            });
            window.camera.start()
                .then(() => { document.getElementById('loading').style.display = 'none'; isVideoReady = true; updateMirror(); loadAsset('bracelet'); })
                .catch(err => { document.getElementById('loading').textContent = "Kamera hiba!"; });
        }

        function toggleMirror() { isMirrored = !isMirrored; updateMirror(); }
        function toggleCamera() { currentCamera = currentCamera === 'environment' ? 'user' : 'environment'; initCamera(); }
        function updateMirror() { videoElement.style.transform = isMirrored ? 'scaleX(-1)' : 'scaleX(1)'; }
        function setMode(mode) {
            currentMode = mode; loadAsset(mode);
            document.getElementById('btn-bracelet').classList.toggle('active', mode === 'bracelet');
            document.getElementById('btn-ring').classList.toggle('active', mode === 'ring');
        }

        initCamera(); animate();
    </script>
</body>
</html>
