<!-- 
  CosmicAR - 3D Bracelet VTO (Three.js Engine)
  This version uses WebGL/Three.js for real 3D bending and rotation.
  Much more complex logic to simulate Perfect Corp behavior.
-->
<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CosmicAR - 3D VTO Engine</title>
    
    <!-- Three.js Library (Core 3D Engine) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            background: #000; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #app-container {
            width: 100%; height: 100%; max-width: 480px; margin: 0 auto;
            position: relative; background: #000; overflow: hidden;
        }

        @media (min-width: 481px) {
            body { background: #1a1a1a; display: flex; align-items: center; justify-content: center; }
            #app-container { height: 90vh; aspect-ratio: 9/16; border-radius: 24px; box-shadow: 0 20px 60px rgba(0,0,0,0.6); }
        }

        /* LAYERS */
        #video-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; object-fit: cover; }
        #input_video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        
        /* 3D Canvas Layer */
        #three-canvas-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none; /* Allow clicks to pass through to UI */
        }

        /* UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; pointer-events: none; }
        
        #instruction-text {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: white; padding: 12px 20px; border-radius: 24px;
            font-size: 14px; text-align: center; backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.15); white-space: nowrap;
        }

        .btn {
            pointer-events: auto; background: rgba(30,30,30,0.8); backdrop-filter: blur(12px);
            color: white; border: 1px solid rgba(255,255,255,0.15); border-radius: 16px;
            font-weight: 600; cursor: pointer; transition: all 0.2s; font-size: 12px;
        }
        .btn:active { transform: scale(0.95); background: rgba(50,50,50,0.9); }

        .top-controls { position: absolute; top: 10px; left: 0; width: 100%; display: flex; justify-content: space-between; padding: 0 12px; }
        .icon-btn { padding: 8px 12px; }

        .bottom-controls {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 92%; display: flex; flex-direction: column; gap: 12px; pointer-events: auto;
        }

        .mode-selector { display: flex; gap: 6px; background: rgba(30,30,30,0.85); padding: 4px; border-radius: 20px; backdrop-filter: blur(12px); }
        .mode-btn {
            flex: 1; background: transparent; color: rgba(255,255,255,0.6); border: none; padding: 10px;
            border-radius: 16px; font-size: 13px; cursor: pointer; transition: all 0.2s; font-weight: 600;
        }
        .mode-btn.active { background: #fff; color: #000; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }

        .finger-controls { display: none; gap: 10px; background: rgba(30,30,30,0.85); padding: 6px 14px; border-radius: 20px; align-items: center; justify-content: center; backdrop-filter: blur(12px); }
        .finger-controls.visible { display: flex; }
        .finger-btn { background: rgba(255,255,255,0.15); color: white; border: none; width: 32px; height: 32px; border-radius: 50%; font-size: 14px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .finger-label { color: white; font-size: 13px; font-weight: 600; min-width: 90px; text-align: center; }

        .loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; z-index: 1000; background: rgba(0,0,0,0.95); padding: 30px 40px; border-radius: 20px; font-size: 14px; text-align: center; border: 1px solid rgba(255,255,255,0.1); }
    </style>
</head>
<body>

    <div id="app-container">
        <div class="loading" id="loading">3D Motor inicializ√°l√°sa...</div>

        <!-- Video Background -->
        <div id="video-layer">
            <video id="input_video" playsinline></video>
        </div>

        <!-- 3D Rendering Layer -->
        <div id="three-canvas-container"></div>

        <!-- UI Overlay -->
        <div id="ui-layer">
            <div class="top-controls">
                <button class="btn icon-btn" onclick="toggleMirror()">üîÑ T√ºk√∂r</button>
                <button class="btn icon-btn" onclick="toggleCamera()">üì∑ Kamera</button>
            </div>

            <div id="instruction-text">Tartsd a csukl√≥dat a kamera fel√©</div>
            
            <div class="bottom-controls">
                <div class="mode-selector">
                    <button class="mode-btn active" id="btn-bracelet" onclick="setMode('bracelet')">üìø Kark√∂t≈ë</button>
                    <button class="mode-btn" id="btn-ring" onclick="setMode('ring')">üíç Gy≈±r≈±</button>
                </div>
                <div class="finger-controls" id="finger-controls">
                    <button class="finger-btn" onclick="prevFinger()">‚óÄ</button>
                    <div class="finger-label" id="finger-label">Gy≈±r≈±sujj</div>
                    <button class="finger-btn" onclick="nextFinger()">‚ñ∂</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 1. KONFIGUR√ÅCI√ì ---
        const CONFIG = {
            assetsPath: './assets/',
            debugMode: false, // True ha akarod l√°tni a csontv√°zat
            smoothing: 0.15,
            wristPositionBias: 0.8, // 0.8 = lejjebb, 0.5 = k√∂z√©p
            baseScaleBracelet: 1.5,
            baseScaleRing: 1.0,
            cylinderRadius: 3.5 // Alap sug√°r a kark√∂t≈ë hengerhez
        };

        // --- 2. GLOBAL STATE ---
        let currentMode = 'bracelet';
        let currentFingerIndex = 2;
        let currentCamera = 'environment';
        let isMirrored = true;
        let isVideoReady = false;
        
        // MediaPipe State
        let handData = {
            detected: false,
            wrist: new THREE.Vector3(),
            midBase: new THREE.Vector3(),
            indexBase: new THREE.Vector3(),
            pinkyBase: new THREE.Vector3(),
            isPalmFacingUp: false,
            wristWidth: 0.1
        };

        // Three.js Objects
        let scene, camera, renderer;
        let braceletGroup, braceletMesh, dashedArcMesh;
        let ringGroup, ringMesh;
        let debugSpheres = [];

        // --- 3. THREE.JS INITIALIZATION ---
        function initThreeJS() {
            const container = document.getElementById('three-canvas-container');
            
            // Scene
            scene = new THREE.Scene();
            
            // Camera (Perspekt√≠v kamera a m√©lys√©ghez)
            camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 0.1, 1000);
            camera.position.z = 20; // Kamera t√°vols√°g

            // Renderer (√Åtl√°tsz√≥ h√°tt√©r a vide√≥hoz)
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            // --- CREATE OBJECTS ---
            createBracelet();
            createDashedArc();
            createRing();
            createDebugHelpers();

            // Resize handler
            window.addEventListener('resize', onWindowResize);
            
            // Start Loop
            animateThree();
        }

        function createBracelet() {
            braceletGroup = new THREE.Group();

            // Texture loader
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load(CONFIG.assetsPath + 'bracelet.png'); // Meg kellene v√°rnia a loadot, de most aszinkron
            
            // Geometry: CylinderSegment (Henger r√©szlet)
            // Fels≈ë √©s als√≥ sug√°r megegyezik -> cs≈ë
            // Magas: vastags√°ga
            // RadialSegments: g√∂rd√ºl√©kenys√©g
            const geometry = new THREE.CylinderGeometry(
                CONFIG.cylinderRadius, CONFIG.cylinderRadius, 
                2.5, // Magass√°g
                32, 1, true, // Open ended (√ºres a teteje √©s alja)
                0, Math.PI * 1.5 // 270 fokos √≠v (hogy ne legyen teljes k√∂r)
            );

            // Material
            const material = new THREE.MeshBasicMaterial({ 
                map: texture,
                transparent: true,
                opacity: 1,
                side: THREE.DoubleSide,
                depthTest: false, // Fontos: ne v√°gja le a t√°rgyakat a kamera miatt
                depthWrite: false
            });

            braceletMesh = new THREE.Mesh(geometry, material);
            // Forgatjuk, hogy a varr√°s ne legyen l√°that√≥, vagy a text√∫ra j√≥l illeszkedjen
            braceletMesh.rotation.y = Math.PI / 2; 

            braceletGroup.add(braceletMesh);
            scene.add(braceletGroup);
        }

        function createDashedArc() {
            // Torus Geometry (T√≥rusz / Karika)
            const geometry = new THREE.TorusGeometry(CONFIG.cylinderRadius + 0.2, 0.15, 8, 50, Math.PI * 1.5);
            
            // Dashed effect helper (simulated with gaps or just a solid arc for now as Three.js dashed lines are complex on 3D shapes)
            // Simple solid arc for stability
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.8,
                depthTest: false,
                depthWrite: false
            });

            dashedArcMesh = new THREE.Mesh(geometry, material);
            dashedArcMesh.rotation.x = Math.PI / 2; // Flat relative to cylinder
            
            // Add to bracelet group initially, but we will control opacity separately
            // Actually, let's put it in the scene but sync position
            braceletGroup.add(dashedArcMesh);
            dashedArcMesh.visible = false;
        }

        function createRing() {
            ringGroup = new THREE.Group();
            
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load(CONFIG.assetsPath + 'ring.png');

            // Ring Geometry (Simplified Cylinder)
            const geometry = new THREE.CylinderGeometry(1.2, 1.2, 0.5, 32, 1, true);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 1,
                side: THREE.DoubleSide,
                depthTest: false,
                depthWrite: false
            });

            ringMesh = new THREE.Mesh(geometry, material);
            ringMesh.rotation.y = Math.PI / 2;
            ringGroup.add(ringMesh);
            scene.add(ringGroup);
            ringGroup.visible = false;
        }

        function createDebugHelpers() {
            if (!CONFIG.debugMode) return;
            const geo = new THREE.SphereGeometry(0.2, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            for(let i=0; i<21; i++) {
                const s = new THREE.Mesh(geo, mat);
                scene.add(s);
                debugSpheres.push(s);
                s.visible = false;
            }
        }

        function onWindowResize() {
            const container = document.getElementById('three-canvas-container');
            camera.aspect = container.offsetWidth / container.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.offsetWidth, container.offsetHeight);
        }

        // --- 4. MATH HELPERS (COMPLEX) ---
        
        // Convert MediaPipe (0-1) to Three.js World Coordinates
        function normalizeToThree(x, y, z, screenW, screenH) {
            // K√©pkoordin√°t√°k inverzelve Y tengelyen, √©s k√∂z√©pre igaz√≠tva
            const tx = (x - 0.5) * 10; // X sk√°l√°z√°s
            const ty = -(y - 0.5) * (10 * (screenH / screenW)); // Y sk√°l√°z√°s (Aspect ratio korrekci√≥)
            // Z m√©lys√©g: MediaPipe Z √©rt√©k√©t haszn√°ljuk fel (kisebb = k√∂zelebb)
            const tz = z * 10; 
            return new THREE.Vector3(tx, ty, tz);
        }

        // LookAt logic for Quaternion
        function lookAtQuaternion(object3D, target) {
            const targetVec = target.clone();
            const position = object3D.position.clone();
            const m = new THREE.Matrix4();
            
            // N√©zd meg a c√©lt, "up" ir√°ny a k√©z h√°ta fel√©
            const up = new THREE.Vector3(0, 1, 0); 
            m.lookAt(position, targetVec, up);
            
            const quat = new THREE.Quaternion();
            quat.setFromRotationMatrix(m);
            object3D.quaternion.slerp(quat, 0.2); // Sim√≠tott forg√°s
        }

        // --- 5. MEDIAPIPE LOGIC ---
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        
        hands.onResults((results) => {
            if (!isVideoReady) return;
            
            const container = document.getElementById('app-container');
            const screenW = container.offsetWidth;
            const screenH = container.offsetHeight;

            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                handData.detected = false;
                resetObjects();
                return;
            }

            handData.detected = true;
            const lm = results.multiHandLandmarks[0];

            // --- LANDMARKS EXTRACT ---
            const wrist = normalizeToThree(lm[0].x, lm[0].y, lm[0].z, screenW, screenH);
            const midBase = normalizeToThree(lm[9].x, lm[9].y, lm[9].z, screenW, screenH);
            const indexBase = normalizeToThree(lm[5].x, lm[5].y, lm[5].z, screenW, screenH);
            const pinkyBase = normalizeToThree(lm[17].x, lm[17].y, lm[17].z, screenW, screenH);

            handData.wrist.copy(wrist);
            handData.midBase.copy(midBase);
            handData.indexBase.copy(indexBase);
            handData.pinkyBase.copy(pinkyBase);

            // --- PALM UP DETECTION (Z-DEPTH) ---
            // Kisebb Z = k√∂zelebb van a kamer√°hoz.
            const zDiff = lm[9].z - lm[0].z;
            const threshold = 0.02; // √ârz√©kenys√©g
            
            // Hysteresis a villog√°s ellen
            if (zDiff < -threshold) handData.isPalmFacingUp = false; // Teny√©r lefel√©
            else if (zDiff > threshold) handData.isPalmFacingUp = true; // Teny√©r felfel√©

            // --- SIZE CALCULATION ---
            const distIndexPinky = indexBase.distanceTo(pinkyBase);
            handData.wristWidth = distIndexPinky;

            // Debug Visuals
            if(CONFIG.debugMode) {
                debugSpheres.forEach((s, i) => {
                    s.position.copy(normalizeToThree(lm[i].x, lm[i].y, lm[i].z, screenW, screenH));
                    s.visible = true;
                });
            }
        });

        // --- 6. OBJECT UPDATES (RENDER LOOP) ---
        function resetObjects() {
            if(braceletGroup) braceletGroup.visible = false;
            if(ringGroup) ringGroup.visible = false;
            if(CONFIG.debugMode) debugSpheres.forEach(s => s.visible = false);
        }

        function updateBracelet() {
            if (!handData.detected) return;
            braceletGroup.visible = true;
            ringGroup.visible = false;

            // 1. Poz√≠ci√≥ (Wrist √©s MidBase kever√©se)
            const targetPos = new THREE.Vector3().copy(handData.wrist);
            const targetPos2 = new THREE.Vector3().copy(handData.midBase);
            
            // Lerp position logic similar to previous JS
            targetPos.lerp(targetPos2, 1 - CONFIG.wristPositionBias);
            braceletGroup.position.lerp(targetPos, CONFIG.smoothing);

            // 2. Sk√°l√°z√°s (Csukl√≥ sz√©less√©g alapj√°n)
            // A henger sugar√°t m√≥dos√≠tjuk
            const scaleRatio = handData.wristWidth * CONFIG.baseScaleBracelet;
            const s = Math.max(0.5, Math.min(scaleRatio, 3.0));
            braceletGroup.scale.set(s, s * 0.5, s); // Y-t kisebbre hagyjuk (vastags√°g)

            // 3. Forgat√°s (Komplex Quaternion LookAt)
            // A kark√∂t≈ënek a teny√©r "tengelye" ment√©n kell √°llnia
            lookAtQuaternion(braceletGroup, handData.midBase);

            // 4. L√°that√≥s√°g logika (Arc vs Kark√∂t≈ë)
            if (handData.isPalmFacingUp) {
                // Teny√©r felfel√© -> Arc l√°tszik
                braceletMesh.visible = false;
                dashedArcMesh.visible = true;
                dashedArcMesh.material.opacity = 1;
            } else {
                // Teny√©r lefel√© -> Kark√∂t≈ë l√°tszik
                braceletMesh.visible = true;
                braceletMesh.material.opacity = 1;
                dashedArcMesh.visible = false;
            }
        }

        function updateRing() {
            if (!handData.detected) return;
            ringGroup.visible = true;
            braceletGroup.visible = false;

            // Ring logic placeholder (needs specific finger landmarks)
            // Currently reusing wrist/mid for testing logic structure
            const targetPos = new THREE.Vector3().copy(handData.midBase);
            ringGroup.position.lerp(targetPos, CONFIG.smoothing);
            ringGroup.scale.setScalar(1.0); 
        }

        function animateThree() {
            requestAnimationFrame(animateThree);

            if (currentMode === 'bracelet') {
                updateBracelet();
            } else {
                updateRing();
            }

            renderer.render(scene, camera);
        }

        // --- 7. UI LOGIC & CAMERA ---
        function initCamera() {
            document.getElementById('loading').style.display = 'block';
            const video = document.getElementById('input_video');
            
            if (window.camera) try { window.camera.stop(); } catch(e){}

            window.camera = new Camera(video, {
                onFrame: async () => await hands.send({image: video}),
                width: 1280, height: 720, facingMode: currentCamera
            });

            window.camera.start()
                .then(() => {
                    document.getElementById('loading').style.display = 'none';
                    isVideoReady = true;
                    updateMirror();
                })
                .catch(err => {
                    console.error(err);
                    document.getElementById('loading').textContent = "Kamera hiba!";
                });
        }

        function toggleMirror() { isMirrored = !isMirrored; updateMirror(); }
        function toggleCamera() { currentCamera = currentCamera === 'environment' ? 'user' : 'environment'; initCamera(); }
        function updateMirror() { document.getElementById('input_video').style.transform = isMirrored ? 'scaleX(-1)' : 'scaleX(1)'; }
        
        function setMode(mode) {
            currentMode = mode;
            document.getElementById('btn-bracelet').classList.toggle('active', mode === 'bracelet');
            document.getElementById('btn-ring').classList.toggle('active', mode === 'ring');
            document.getElementById('finger-controls').classList.toggle('visible', mode === 'ring');
        }

        function nextFinger() { currentFingerIndex = (currentFingerIndex + 1) % 4; document.getElementById('finger-label').textContent = ['Mutat√≥ujj', 'K√∂z√©ps≈ëujj', 'Gy≈±r≈±sujj', 'Kisujj'][currentFingerIndex]; }
        function prevFinger() { currentFingerIndex = (currentFingerIndex - 1 + 4) % 4; document.getElementById('finger-label').textContent = ['Mutat√≥ujj', 'K√∂z√©ps≈ëujj', 'Gy≈±r≈±sujj', 'Kisujj'][currentFingerIndex]; }

        // --- INIT SEQUENCE ---
        window.onload = () => {
            initThreeJS();
            initCamera();
            setMode('bracelet');
        };

    </script>
</body>
</html>
