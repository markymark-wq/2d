<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CosmicAR - Perfect VTO Logic</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body {
            background: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: sans-serif;
        }

        #app-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 480px;
            overflow: hidden;
        }

        /* VIDEO LAYER */
        #video-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
        
        #input_video {
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        /* AR LAYER */
        #ar-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            perspective: 1000px; /* Fontos a térbeli hatáshoz */
        }

        /* ANCHOR - Ez követi a 0-ás pontot (Csukló) */
        #wrist-anchor {
            position: absolute;
            top: 0; left: 0;
            width: 0; height: 0;
            transform-style: preserve-3d;
            will-change: transform;
        }

        /* CONTAINER - Ez végzi a forgatást */
        #jewelry-container {
            position: absolute;
            top: 0; left: 0;
            width: 0; height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transform-style: preserve-3d;
        }

        /* MAGA A KÉP */
        #jewelry-img {
            display: block;
            position: absolute;
            /* A karkötő közepe legyen a forgásponton */
            transform: translate(-50%, -50%); 
            max-width: none;
            /* Árnyék a bőrre */
            filter: drop-shadow(0 5px 8px rgba(0,0,0,0.4));
        }

        /* DEBUG PONT (Borsócsont helye) - Teszteléshez hagytam bent, kikapcsolható */
        .debug-dot {
            width: 6px; height: 6px;
            background: red;
            border-radius: 50%;
            position: absolute;
            left: -3px; top: -3px;
            display: none; /* Ha látni akarod a rögzítési pontot, vedd ki ezt */
        }

        /* UI */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 20;
            pointer-events: none;
        }

        .status-msg {
            position: absolute;
            top: 20%; left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="video-layer">
            <video id="input_video" playsinline></video>
        </div>

        <div id="ar-layer">
            <div id="wrist-anchor">
                <div class="debug-dot"></div> <!-- A piros pötty a 0-ás pont -->
                <div id="jewelry-container">
                    <!-- Itt a karkötő kép -->
                    <img id="jewelry-img" src="./assets/bracelet.png" alt="bracelet" style="display:none;">
                </div>
            </div>
        </div>

        <div id="ui-layer">
            <div id="msg" class="status-msg">Keresem a kezet...</div>
            <div style="position: absolute; bottom: 20px; left: 50%; transform:translateX(-50%); pointer-events:auto;">
                 <button onclick="toggleMirror()" style="padding:10px 20px; background:white; border:none; border-radius:8px; font-weight:bold;">Tükör</button>
            </div>
        </div>
    </div>

    <script>
        // --- BEÁLLÍTÁSOK ---
        const CONFIG = {
            smoothing: 0.15,      // Mennyire legyen "ragadós" a mozgás (0.1 lassú, 0.9 gyors)
            scaleMultiplier: 2.8, // Karkötő méret szorzó
            yOffset: 0.05,        // Mennyivel toljuk le a csuklócsontról a kar felé (hogy ne a kézfejen legyen)
        };

        const videoElement = document.getElementById('input_video');
        const wristAnchor = document.getElementById('wrist-anchor');
        const jewelryContainer = document.getElementById('jewelry-container');
        const jewelryImg = document.getElementById('jewelry-img');
        const msg = document.getElementById('msg');

        let isMirrored = true;
        
        // Simított értékek tárolása
        let target = { x: 0, y: 0, scale: 1, rotZ: 0, rotY: 0, rotX: 0, opacity: 0 };
        let current = { x: 0, y: 0, scale: 1, rotZ: 0, rotY: 0, rotX: 0, opacity: 0 };

        // Asset betöltése
        const img = new Image();
        img.src = './assets/bracelet.png';
        img.onload = () => {
            jewelryImg.src = img.src;
            jewelryImg.style.display = 'block';
            // Beállítjuk a méretarányt
            const aspect = img.naturalHeight / img.naturalWidth;
            jewelryImg.style.width = '100px'; // Bázis szélesség
            jewelryImg.style.height = (100 * aspect) + 'px';
        };

        // --- MATH SEGÉD ---
        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end;
        }

        // Vektor műveletek a 3D számításhoz
        const Vector = {
            sub: (v1, v2) => ({ x: v1.x - v2.x, y: v1.y - v2.y, z: v1.z - v2.z }),
            normalize: (v) => {
                const len = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
                return { x: v.x/len, y: v.y/len, z: v.z/len };
            },
            cross: (a, b) => ({
                x: a.y * b.z - a.z * b.y,
                y: a.z * b.x - a.x * b.z,
                z: a.x * b.y - a.y * b.x
            }),
            dot: (a, b) => a.x * b.x + a.y * b.y + a.z * b.z
        };

        // --- MEDIAPIPE LOGIKA (A LÉNYEG) ---
        function onResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                target.opacity = 0;
                msg.style.opacity = 1;
                return;
            }
            msg.style.opacity = 0;

            const lm = results.multiHandLandmarks[0];       // 2D képernyő pontok
            const worldLm = results.multiHandWorldLandmarks[0]; // 3D méter pontok (EZ KELL A FORGÁSHOZ!)

            // 1. POZÍCIÓ: Kizárólag a 0-ás ponthoz (Wrist) rögzítünk
            // Nem átlagolunk! Ez a "Perfect Corp" titok egyik része.
            const wristX = lm[0].x;
            const wristY = lm[0].y;

            // 2. FORGATÁS SZÁMÍTÁSA (3D VEKTOROKBÓL)
            
            // "Arm Vector": Csuklótól (0) a Középső ujj tövéig (9)
            // Ez adja meg, merre áll a kar a térben.
            const P0 = worldLm[0];
            const P9 = worldLm[9];
            const P5 = worldLm[5];  // Mutatóujj töve
            const P17 = worldLm[17]; // Kisujj töve

            // Fő tengely (hosszanti)
            const armVec = Vector.sub(P9, P0);
            
            // Kereszt tengely (tenyér szélessége)
            const palmVec = Vector.sub(P17, P5);

            // Tenyér Normálvektora (Merre néz a tenyér?)
            // Keresztszorzat a hosszanti és szélességi vektorból
            const normal = Vector.normalize(Vector.cross(armVec, palmVec));

            // ROTATION Z (Roll - Képernyő síkjában forgás)
            // Itt a 2D koordináták pontosabbak a képernyőre illesztéshez
            let angleRad = Math.atan2(lm[9].y - lm[0].y, lm[9].x - lm[0].x);
            let angleDeg = angleRad * (180 / Math.PI);
            
            // A karkötő alapból vízszintes, a kar függőleges lehet. Korrekció: +90 fok
            let rotZ = angleDeg + 90;

            if (isMirrored) {
                rotZ = -angleDeg - 90; 
            }

            // ROTATION Y (Yaw - Oldalra fordulás)
            // Ezt a "normal" vektor X komponense adja meg.
            // Ha a normal.x nagy, akkor oldalra néz a tenyér.
            let rotY = normal.x * -90; // Kísérleti szorzó

            // ROTATION X (Pitch - Előre/Hátra dőlés)
            // Ezt a "normal" vektor Y/Z viszonya adja
            let rotX = normal.y * 90;

            // SKÁLA (MÉRET)
            // A csukló szélességét becsüljük a 3D pontok távolságából (5 és 17 között)
            // Ez pontosabb, mert nem torzul, ha közelebb hozod a kezed.
            const dist3D = Math.sqrt(
                Math.pow(P5.x - P17.x, 2) +
                Math.pow(P5.y - P17.y, 2) +
                Math.pow(P5.z - P17.z, 2)
            );
            
            // Konvertálás pixel méretre
            let scale = dist3D * 100 * CONFIG.scaleMultiplier; 

            // --- KORREKCIÓK ---
            // Tükrözés kezelése a pozíciónál
            let finalX = isMirrored ? (1 - wristX) : wristX;
            let finalY = wristY;

            // ÉRTÉKEK BEÁLLÍTÁSA A TARGETBE
            target.x = finalX;
            target.y = finalY;
            target.rotZ = rotZ;
            target.rotY = rotY; 
            target.rotX = rotX * 0.5; // Kicsit visszafogjuk a dőlést
            target.scale = scale;
            target.opacity = 1;
        }

        // --- RENDER LOOP ---
        function animate() {
            // Lerp (simítás) a jitter ellen
            current.x = lerp(current.x, target.x, CONFIG.smoothing);
            current.y = lerp(current.y, target.y, CONFIG.smoothing);
            current.rotZ = lerp(current.rotZ, target.rotZ, CONFIG.smoothing);
            current.rotY = lerp(current.rotY, target.rotY, CONFIG.smoothing);
            current.rotX = lerp(current.rotX, target.rotX, CONFIG.smoothing);
            current.scale = lerp(current.scale, target.scale, CONFIG.smoothing);
            current.opacity = lerp(current.opacity, target.opacity, 0.2);

            // Képernyő méretek
            const w = appContainer.offsetWidth;
            const h = appContainer.offsetHeight;

            // 1. ANCHOR MOZGATÁSA (Pixelre pontosan a 0-ás landmarkra)
            wristAnchor.style.left = (current.x * w) + 'px';
            wristAnchor.style.top = (current.y * h) + 'px';

            // 2. FORGATÁS ÉS OFFSET
            // Fontos: A Z forgatás a csukló tengelye
            // A translateY azért kell, hogy a karkötő ne a csont közepén, hanem kicsit lejjebb legyen a karon
            // A 3D forgatásokat (rotateX, rotateY) is itt alkalmazzuk
            
            wristAnchor.style.transform = `rotateZ(${current.rotZ}deg)`;

            jewelryContainer.style.transform = `
                translateY(${current.scale * 40 * CONFIG.yOffset}px) 
                rotateX(${current.rotX}deg)
                rotateY(${current.rotY}deg)
            `;

            jewelryImg.style.width = current.scale * 100 + 'px'; // Base width scale
            jewelryImg.style.opacity = current.opacity;

            requestAnimationFrame(animate);
        }

        // --- SETUP ---
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280, height: 720,
            facingMode: 'environment' // Kezdésnek hátsó kamera
        });

        camera.start();

        function toggleMirror() {
            isMirrored = !isMirrored;
            videoElement.style.transform = isMirrored ? 'scaleX(-1)' : 'scaleX(1)';
        }
    </script>
</body>
</html>
