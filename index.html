<!-- 
  2D Overlay - Fixed Version
  cosmic-engine | 2026-02-06
  Csukl√≥pontos pozicion√°l√°s, k√ºl√∂nb√∂z≈ë kezetart√°sokhoz
-->
<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2D VTO - Csukl√≥ Fix</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            touch-action: none;
        }

        #video-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 1;
        }
        #input_video {
            position: absolute; width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #scene-3d {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            perspective: 1500px;
            overflow: visible;
        }

        #wrist-anchor {
            position: absolute; top: 0; left: 0; width: 0; height: 0;
            transform-style: preserve-3d;
            will-change: transform;
        }

        #jewelry-card {
            position: absolute;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            /* √Årny√©k az img-re ker√ºl, ne ide */
        }

        #jewelry-img {
            display: block;
            max-width: none; 
            max-height: none;
            transform: translate(-50%, -50%);
            /* Perfect Corp szint≈± finom √°rny√©k */
            filter: drop-shadow(0 12px 20px rgba(0,0,0,0.4));
            /* A k√©p sz√©less√©ge dinamikusan √°ll√≠t√≥dik JS-b≈ël */
        }

        /* Szaggatott √≠v */
        #dashed-arc {
            position: absolute;
            border-radius: 50%;
            border: 3px dashed rgba(255, 255, 255, 0.9);
            transform: translate(-50%, -50%) translateZ(-60px);
            pointer-events: none;
            opacity: 0;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }

        @keyframes dash-rotate {
            0% { transform: translate(-50%, -50%) rotate(0deg) translateZ(-60px); }
            100% { transform: translate(-50%, -50%) rotate(360deg) translateZ(-60px); }
        }

        #dashed-arc.animating {
            animation: dash-rotate 6s linear infinite;
        }

        /* UI */
        #instruction-text {
            position: absolute; top: 15%; left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            color: white; padding: 12px 24px; border-radius: 20px;
            font-size: 14px; text-align: center;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
            z-index: 100;
            pointer-events: none;
        }

        .btn {
            position: absolute; z-index: 100;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            background: rgba(0,0,0,0.7);
            color: white; border: 1px solid rgba(255,255,255,0.3);
            padding: 10px 16px; border-radius: 20px;
            font-weight: 600; cursor: pointer;
        }
        .btn:active { transform: scale(0.95); }
        
        #btn-mirror { top: 20px; left: 20px; }
        #btn-cam { top: 20px; right: 20px; }
        
        .mode-selector {
            position: absolute; bottom: 30px; left: 50%;
            transform: translateX(-50%);
            display: flex; gap: 10px;
            background: rgba(0,0,0,0.7); padding: 8px; border-radius: 25px;
            z-index: 100;
        }
        .mode-btn {
            flex: 1; background: transparent; color: rgba(255,255,255,0.6);
            border: none; padding: 12px 24px; border-radius: 18px;
            font-size: 14px; cursor: pointer; transition: all 0.3s;
        }
        .mode-btn.active {
            background: rgba(255,255,255,0.95); color: #000; font-weight: 700;
        }

        .loading {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%); color: white; z-index: 1000;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;
        }
    </style>
</head>
<body>

    <div class="loading" id="loading">Kamera ind√≠t√°sa...</div>

    <div id="video-container">
        <video id="input_video" playsinline></video>
    </div>

    <div id="scene-3d">
        <div id="wrist-anchor">
            <div id="jewelry-card">
                <img id="jewelry-img" src="" alt="jewelry" style="display:none;">
            </div>
            <div id="dashed-arc"></div>
        </div>
    </div>

    <div id="instruction-text">Tartsd a csukl√≥dat a kamera fel√©</div>
    
    <button class="btn" id="btn-mirror" onclick="toggleMirror()">üîÑ T√ºk√∂r</button>
    <button class="btn" id="btn-cam" onclick="toggleCamera()">üì∑ Kamera</button>
    
    <div class="mode-selector">
        <button class="mode-btn active" onclick="setMode('bracelet')">üìø Kark√∂t≈ë</button>
        <button class="mode-btn" onclick="setMode('ring')">üíç Gy≈±r≈±</button>
    </div>

    <script>
        // Konfigur√°ci√≥
        const CONFIG = {
            assetsPath: './assets/',
            smoothing: 0.15,
            // √Åtmenet: 0-25¬∞ csak kark√∂t≈ë, 25-40¬∞ √°tmenet, 40¬∞+ csak √≠v
            fadeStartAngle: 25,
            fadeEndAngle: 40,
            // Z-offset: negat√≠v = k√∂zelebb a kamer√°hoz (el≈ëre), pozit√≠v = h√°tr√©bb
            // -15px kell hogy a b≈ër "f√∂l√©" ker√ºlj√∂n, ne lebegjen
            zOffset: -15
        };

        let state = {
            x: window.innerWidth/2, y: window.innerHeight/2,
            rotX: 0, rotY: 0, rotZ: 0,
            scale: 1, opacity: 1,
            arcOpacity: 0, arcSize: 150
        };
        
        let target = { ...state };
        let isMirrored = true;
        let currentCamera = 'environment';
        let isVideoReady = false;
        let currentMode = 'bracelet';

        // DOM elemek
        const videoElement = document.getElementById('input_video');
        const wristAnchor = document.getElementById('wrist-anchor');
        const jewelryImg = document.getElementById('jewelry-img');
        const jewelryCard = document.getElementById('jewelry-card');
        const dashedArc = document.getElementById('dashed-arc');
        const instructions = document.getElementById('instruction-text');

        // MediaPipe
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // Inicializ√°l√°s
        function initCamera() {
            document.getElementById('loading').style.display = 'block';
            
            const camera = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 1280, height: 720,
                facingMode: currentCamera
            });
            
            camera.start()
                .then(() => {
                    document.getElementById('loading').style.display = 'none';
                    isVideoReady = true;
                    loadAsset('bracelet');
                })
                .catch(err => {
                    console.error(err);
                    document.getElementById('loading').textContent = "Kamera hiba!";
                });
        }

        function loadAsset(type) {
            const img = new Image();
            const src = CONFIG.assetsPath + (type === 'bracelet' ? 'bracelet.png' : 'ring.png');
            
            img.onload = () => {
                jewelryImg.src = src;
                jewelryImg.style.display = 'block';
                // A k√©p magass√°g√°t az ar√°ny alapj√°n sz√°moljuk, sz√©less√©g√©t pedig a csukl√≥hoz igaz√≠tjuk
                const aspect = img.naturalHeight / img.naturalWidth;
                // Alap sz√©less√©g: 200px, ezt sk√°l√°zzuk majd a k√©z m√©ret√©vel
                jewelryImg.dataset.aspect = aspect;
                jewelryImg.style.width = '200px';
                jewelryImg.style.height = (200 * aspect) + 'px';
            };
            img.src = src;
        }

        function toggleMirror() { 
            isMirrored = !isMirrored; 
            videoElement.style.transform = isMirrored ? 'scaleX(-1)' : 'scaleX(1)';
        }
        
        function toggleCamera() { 
            currentCamera = currentCamera === 'environment' ? 'user' : 'environment'; 
            initCamera(); 
        }
        
        function setMode(mode) {
            currentMode = mode;
            loadAsset(mode);
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            instructions.textContent = mode === 'bracelet' ? "Tartsd a csukl√≥dat a kamera fel√©" : "Mutasd az ujjad";
        }

        // Matek helperek
        const lerp = (s, e, f) => s + (e - s) * f;
        const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
        const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

        // F≈ë feldolgoz√≥
        function onResults(results) {
            if (!isVideoReady || !results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                return;
            }

            const lm = results.multiHandLandmarks[0];
            const vRect = videoElement.getBoundingClientRect();
            
            // Landmarks indexek:
            // 0: wrist (csukl√≥)
            // 5: index_base (mutat√≥ ujj t√∂ve) 
            // 9: middle_base (k√∂z√©ps≈ë ujj t√∂ve)
            // 13: ring_base (gy≈±r≈±sujj t√∂ve)
            // 17: pinky_base (kisujj t√∂ve)
            
            const wrist = lm[0];
            const indexBase = lm[5];
            const pinkyBase = lm[17];
            const middleBase = lm[9];

            // 1. POZ√çCI√ì - Pontosan a csukl√≥ra (wrist)
            // Fontos: Ha felfel√© tartod a kezed, a wrist pont van legfel√ºl a k√©perny≈ën (kisebb Y)
            // Adjunk hozz√° egy offsetet, hogy a kark√∂t≈ë a csukl√≥ "k√∂zep√©re" ker√ºlj√∂n
            let wristX = wrist.x;
            let wristY = wrist.y + 0.02; // Kicsit lejjebb tol√°s a csukl√≥ vastags√°g√°nak k√∂zep√©re
            
            // T√ºk√∂rkezel√©s
            if (isMirrored) wristX = 1 - wristX;
            
            // Pixel koordin√°t√°k
            const cx = wristX * vRect.width;
            const cy = wristY * vRect.height;
            
            target.x = cx;
            target.y = cy;

            // 2. ROT√ÅCI√ì - A csukl√≥ sz√©less√©ge alapj√°n (index-pinky)
            // Ez v√≠zszintes tengely ment√©n mutat, ami j√≥l k√∂veti a csukl√≥ elforgat√°s√°t
            const dx = pinkyBase.x - indexBase.x;
            const dy = pinkyBase.y - indexBase.y;
            let angleRad = Math.atan2(dy, dx);
            let angleDeg = angleRad * (180 / Math.PI);
            
            // Korrekci√≥: A kark√∂t≈ë k√©pe √°ltal√°ban v√≠zszintes, adjunk hozz√° 90 fokot
            // hogy a csukl√≥ k√∂r√ºl "√≠veljen"
            let rotZ = angleDeg + 90;
            
            if (isMirrored) rotZ = -rotZ;
            
            target.rotZ = rotZ;
            
            // 3. 3D ORIENT√ÅCI√ì (Pitch/Yaw) - A k√©z d≈ël√©ssz√∂g√©b≈ël
            // Ha felfel√© tartod a kezed, a "pitch" (rotX) fog v√°ltozni
            // Sz√°m√≠tjuk a k√©z s√≠kj√°nak d≈ël√©ssz√∂g√©t a kamera fel√©
            
            // Vektor a wrist-t≈ël a middle_base-ig (ez mutatja a k√©z "fel" ir√°ny√°t)
            const upDx = middleBase.x - wrist.x;
            const upDy = middleBase.y - wrist.y;
            const handLength = Math.sqrt(upDx*upDx + upDy*upDy);
            
            // Normaliz√°lt vektor
            const normX = upDx / handLength;
            const normY = upDy / handLength;
            
            // Pitch (X tengely k√∂r√ºli elforgat√°s) - mennyire "felfel√©" tartja a kez√©t
            // Ha normY k√∂zel -1 (felfel√© mutat), akkor a k√©z f√ºgg≈ëleges
            const pitchFactor = -normY; // -1 (felfel√©) ... 1 (lefel√©)
            target.rotX = pitchFactor * 45; // Max 45 fokos d≈ël√©s
            
            // Yaw (Y tengely k√∂r√ºli elforgat√°s) - oldalra fordul√°s
            // Ha a csukl√≥ sz√©less√©ge (index-pinky) kicsi, akkor oldalr√≥l l√°tjuk
            const wristWidth = dist(indexBase, pinkyBase);
            const wristWidthPx = wristWidth * vRect.width;
            
            // Referencia: 100px sz√©les csukl√≥ = front√°lis, 40px = oldaln√©zet
            const visibilityFactor = clamp((wristWidthPx - 40) / 60, 0, 1); // 0 = oldal, 1 = front
            target.rotY = (1 - visibilityFactor) * 60 * (isMirrored ? -1 : 1); // Max 60 fok
            
            // 4. SK√ÅL√ÅZ√ÅS - A csukl√≥ sz√©less√©g√©hez igaz√≠tva
            // Ez automatikusan alkalmazkodik f√©rfi/n≈ëi k√©zhez
            const baseWidth = 180; // Referencia px
            const scale = (wristWidthPx / baseWidth) * (currentMode === 'bracelet' ? 1.2 : 0.6);
            target.scale = clamp(scale, 0.5, 2.5);
            
            // 5. √ÅTT≈∞N√âS - Ha oldalra fordul a k√©z (kicsi a wristWidth), akkor fade
            // 25-40 fok k√∂z√∂tt √°tmenet
            const absYaw = Math.abs(target.rotY);
            let jewelryOpacity = 1;
            let arcOp = 0;
            
            if (absYaw < CONFIG.fadeStartAngle) {
                jewelryOpacity = 1;
                arcOp = 0;
            } else if (absYaw > CONFIG.fadeEndAngle) {
                jewelryOpacity = 0;
                arcOp = 1;
            } else {
                const t = (absYaw - CONFIG.fadeStartAngle) / (CONFIG.fadeEndAngle - CONFIG.fadeStartAngle);
                jewelryOpacity = 1 - t;
                arcOp = t;
            }
            
            target.opacity = jewelryOpacity;
            target.arcOpacity = arcOp;
            target.arcSize = wristWidthPx * 2.5; // Az √≠v a csukl√≥ k√∂r√ºl
        }

        // Anim√°ci√≥s loop
        function animate() {
            // Sim√≠t√°s
            state.x = lerp(state.x, target.x, CONFIG.smoothing);
            state.y = lerp(state.y, target.y, CONFIG.smoothing);
            state.rotX = lerp(state.rotX, target.rotX, CONFIG.smoothing);
            state.rotY = lerp(state.rotY, target.rotY, CONFIG.smoothing);
            state.rotZ = lerp(state.rotZ, target.rotZ, CONFIG.smoothing);
            state.scale = lerp(state.scale, target.scale, CONFIG.smoothing);
            state.opacity = lerp(state.opacity, target.opacity, 0.1);
            state.arcOpacity = lerp(state.arcOpacity, target.arcOpacity, 0.1);
            state.arcSize = lerp(state.arcSize, target.arcSize, CONFIG.smoothing);

            // Pozicion√°l√°s
            wristAnchor.style.transform = `translate3d(${state.x}px, ${state.y}px, 0)`;

            // √âkszer transzform√°ci√≥
            // Fontos sorrend: translateZ (k√∂zelebb/h√°tr√©bb), rotX (d≈ël√©s), rotY (oldalra), rotZ (elforgat√°s), scale
            jewelryCard.style.transform = `
                translateZ(${CONFIG.zOffset}px)
                rotateX(${state.rotX}deg)
                rotateY(${state.rotY}deg) 
                rotateZ(${state.rotZ}deg)
                scale(${state.scale})
            `;
            jewelryCard.style.opacity = state.opacity;

            // Szaggatott √≠v
            dashedArc.style.width = state.arcSize + 'px';
            dashedArc.style.height = state.arcSize + 'px';
            dashedArc.style.opacity = state.arcOpacity;
            
            if (state.arcOpacity > 0.1) {
                dashedArc.classList.add('animating');
            } else {
                dashedArc.classList.remove('animating');
            }

            requestAnimationFrame(animate);
        }

        // Start
        initCamera();
        animate();
    </script>
</body>
</html>
