<!-- 
  BRACELET VTO - 2D Overlay
  cosmic-engine | 2026-02-04
  Egyszer≈± 2D k√©pk√∂vet√©s MediaPipe Hands-sel
-->
<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√âkszer VTO - 2D Overlay</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            font-family: Arial, sans-serif;
        }
        #input-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 8px;
            color: white;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        #video {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 8px;
            opacity: 0.7;
            transform: scaleX(-1); /* T√ºk√∂rk√©p */
        }
        input[type="file"] {
            margin-top: 10px;
        }
        .instruction {
            font-size: 12px;
            color: #aaa;
            margin-top: 10px;
        }
    </style>
</head>
<body>

    <div id="input-container">
        <label>üìø T√∂ltsd fel a kark√∂t≈ë k√©p√©t (PNG √°tl√°tsz√≥ h√°tt√©rrel):</label>
        <input type="file" id="imageInput" accept="image/png,image/jpeg">
        <div class="instruction">
            A k√©p a csukl√≥dra fog ker√ºlni. Mozgasd a kezedet!
        </div>
    </div>

    <!-- Kamera preview (kicsi, sarokban) -->
    <video id="video" playsinline></video>
    
    <!-- F≈ë canvas, ide rajzolunk -->
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const videoElement = document.getElementById('video');
        
        let jewelryImage = null;
        let hands = null;
        let camera = null;
        
        // K√©p felt√∂lt√©s kezel√©se
        document.getElementById('imageInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    jewelryImage = new Image();
                    jewelryImage.onload = () => {
                        console.log('K√©p bet√∂ltve:', jewelryImage.width, 'x', jewelryImage.height);
                    };
                    jewelryImage.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Canvas m√©ret be√°ll√≠t√°sa ablakhoz
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Seg√©df√ºggv√©ny: k√©t pont t√°vols√°ga
        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        // Seg√©df√ºggv√©ny: sz√∂g k√©t pont k√∂z√∂tt (radi√°n)
        function angle(p1, p2) {
            return Math.atan2(p2.y - p1.y, p2.x - p1.x);
        }

        // MediaPipe Hands callback
        function onResults(results) {
            // T√∂rl√©s
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // T√ºk√∂r effekt: a canvas-t is t√ºkr√∂zz√ºk, hogy a k√©zmozg√°s "term√©szetes" legyen
            ctx.save();
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
            
            // Kamera k√©p rajzol√°sa (opcion√°lis, ha nem akarod l√°tni a h√°tteret, kommentezd ki)
            // ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Landmark indexek:
                // 0: csukl√≥ (WRIST)
                // 5: mutat√≥ujj alap (INDEX_FINGER_MCP)
                // 17: kisujj alap (PINKY_MCP)
                // 9: k√∂z√©ps≈ë ujj alap (MIDDLE_FINGER_MCP)
                
                const wrist = landmarks[0];
                const indexBase = landmarks[5];
                const pinkyBase = landmarks[17];
                const middleBase = landmarks[9];
                
                // Poz√≠ci√≥: a csukl√≥ √©s a k√∂z√©ps≈ë ujj k√∂z√∂tt (kicsit feljebb a csukl√≥n√°l)
                const centerX = (wrist.x + middleBase.x) / 2;
                const centerY = (wrist.y + middleBase.y) / 2;
                
                // Scale: a k√©z sz√©less√©ge (mutat√≥ujj alap - kisujj alap t√°vols√°ga)
                // Ez adja meg, hogy milyen sz√©les a k√©zfej
                const handWidth = distance(indexBase, pinkyBase);
                const baseScale = handWidth * 2.5; // Finomhangolhat√≥ szorz√≥
                
                // Forgat√°s: a k√©z hossztengelye (csukl√≥ -> k√∂z√©ps≈ë ujj)
                const rotation = angle(wrist, middleBase) + Math.PI / 2; // +90 fok, hogy v√≠zszintes k√©p √°lljon
                
                // Ha van felt√∂lt√∂tt k√©p, rajzoljuk
                if (jewelryImage) {
                    const imgWidth = jewelryImage.width;
                    const imgHeight = jewelryImage.height;
                    const aspect = imgWidth / imgHeight;
                    
                    // M√©retez√©s: a k√©z sz√©less√©g√©hez igaz√≠tva
                    const drawWidth = canvas.width * baseScale;
                    const drawHeight = drawWidth / aspect;
                    
                    // Poz√≠ci√≥ k√©perny≈ëre konvert√°lva (MediaPipe 0-1 koordin√°t√°k)
                    const screenX = centerX * canvas.width;
                    const screenY = centerY * canvas.height;
                    
                    ctx.save();
                    
                    // Transzform√°ci√≥k
                    ctx.translate(screenX, screenY);
                    ctx.rotate(rotation);
                    
                    // DROP SHADOW (az a szaggatott vonal hat√°s alul)
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                    ctx.shadowBlur = 20;
                    ctx.shadowOffsetX = 5;
                    ctx.shadowOffsetY = 10;
                    
                    // K√©p rajzol√°sa k√∂z√©pre igaz√≠tva
                    ctx.drawImage(
                        jewelryImage, 
                        -drawWidth / 2, 
                        -drawHeight / 2, 
                        drawWidth, 
                        drawHeight
                    );
                    
                    ctx.restore();
                }
                
                // Debug: landmark pontok (opcion√°lis, ki is kapcsolhatod)
                /*
                ctx.fillStyle = 'red';
                for (let landmark of landmarks) {
                    const x = landmark.x * canvas.width;
                    const y = landmark.y * canvas.height;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                }
                */
            }
            
            ctx.restore();
        }

        // MediaPipe inicializ√°l√°s
        hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);
        
        // Kamera ind√≠t√°sa
        camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });
        
        camera.start();

    </script>
</body>
</html>